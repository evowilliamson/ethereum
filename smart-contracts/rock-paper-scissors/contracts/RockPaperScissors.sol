pragma solidity ^0.4.24;

import "./Pausible.sol";
import "./SafeMath.sol";

/** RockPaperScissors game according to the commit-reveal pattern to prevent front-running:
 * https://karl.tech/learning-solidity-part-2-voting/. 
 * https://medium.com/modular-network/introduction-to-smart-contract-and-dapp-security-556502629d54
 **/

  /** Happy scenario:
   * 
   * Time     inviter                                  invitee
   * -------------------------------------------------------------------------------------
   * T0       invite(invitee, amount, deadline, id)
   * 
   *
   * 
   * T1                                                accept(id, plainTextMove, password)
   * 
   * 
   * 
   * T2       revealMove(plainTextMove, password)
   * 
   * Note: inviter can cancle until T1
   **/
  
contract RockPaperScissors is Pausible {

    event GameCreated(bytes32 id, address indexed inviter, address indexed invitee, 
        uint256 amount, uint256 deadline);
    event GameAccepted(bytes32 id, address indexed inviter, address indexed invitee);
    event GameFinished(bytes32 id, address indexed winner);
    event GameCancelled(bytes32 id, address indexed byWhom);
    event ProfitPercentageChanged(uint256 newProfitPercentage);
    event FundsWithdrawn(address indexed player);
    event ProfitTransferred(uint256 amount, address toWhere);
    event PlayerToppedUp(uint256 amount, address who);
    event ProfitBenificiaryRegistered(address who);
    

    enum Move { None, Rock, Paper, Scissors}
    enum Outcome { Tie, InviterWins, InviteeWins}

    using SafeMath for uint256;
    
    uint8 public profitPercentage;
    uint256 public profit;
    address public profitBenificiary;
    /**
     * The benificiary address where the profit of the contract can be 
     * send to. Initially, it will be the owner. So the owner can 
     * withdraw the profit. This can be changed though by first 
     * registering a profit benificiary.
     **/

    struct Game {
        address inviter;
        address invitee;
        /**
         * Only store the plaintext move of the invited player
         **/
        Move plaintextMoveInvitee;
        uint256 amount;
        uint256 deadline;
        /**
         * After a game has been finished/cancelled, don't use it anymore. Don't use inviter and invitee
         * to check whether a game has been used/not used, because we will not reset inviter and invitee
         * because of security reason. Once a game is played, inviter must generate a hash that results in 
         * different slot in the games mapping.
         **/
        bool finished;
    }
    
    /** Players' money **/
    mapping (address => uint256) public balances;
    
    /** 
     * Committed moves hashes to game mapping. 
     * The committed move hash generated by the inviting player is used as an id to the game.
     * A committed move hash is generated by combining the address of the inviting player,
     * the plaintext move and a password that is chosen by the inviting player and hashing that. 
     * The password is necessary because the plaintext move and inviting player's address will result in a hash, 
     * but a hacker might deduce a pattern because of the limited amounts of combinations. 
     **/
    mapping (bytes32 => Game) public games;
    
    modifier onlyWhenNotfinished(bytes32 id) {
        require(games[id].finished == false, "Game finished");
        _;
    }

    modifier onlyWhenGameNotExists(bytes32 id) {
        require(games[id].inviter == 0x0, "Game exists");
        _;
    }
    
    modifier onlyWhenValidMove(Move move) {
        require(move >= Move.Rock && move <= Move.Scissors, "Incorrect move");
        _;
    }
    
    modifier onlyWhenPlayer(bytes32 id) {
        require(games[id].inviter == msg.sender ||
                games[id].invitee == msg.sender, "Not a player in this game");        
        _;
    }

    modifier onlyWhenPlayerIsInviter(bytes32 id) {
        require(games[id].inviter == msg.sender, "Not the inviter of this game");        
        _;
    }

    modifier onlyWhenPlayerIsInvitee(bytes32 id) {
        require(games[id].invitee == msg.sender, "Not the invitee of this game");        
        _;
    }
    
    modifier onlyWhenBeforeDeadline(bytes32 id) {
        require(now <= games[id].deadline, "Deadline has passed");
        _;
    }
    
    modifier onlyWhenProfitBenificiary() {
        require(msg.sender == profitBenificiary, "Not the profit benificiary");
        _;
    }
    
    constructor() public {
        profitBenificiary = owner;
        profitPercentage = 5;
    }
    
    /**
     * This function is invoked by the inviting player, committing a move and 
     * registering the address of his/her opponent. The hash that is passed to this 
     * function, serves as an id to the game
     **/
    function invite(address invitee, uint256 secondsToDeadline, bytes32 id) 
        onlyWhenActive
        onlyWhenGameNotExists(id) 
        onlyWhenNotfinished(id) public payable {

        require(invitee != msg.sender, "Cannot invite yourself");
        require(invitee != 0x0, "Invitee must be specified");

        games[id] = 
            Game(msg.sender, invitee, Move.None, msg.value, 
            now + (secondsToDeadline * 1 seconds), false); 

         emit GameCreated(id, msg.sender, invitee, msg.value,  games[id].deadline);

    }

    /**
     * This function is invoked by the invitee. The id of the game will be 
     * provided by the invitee, in addition to his/her plaintext move.
     **/
    function accept(bytes32 id, Move plaintextMoveInvitee) 
        onlyWhenActive
        onlyWhenNotfinished(id) 
        onlyWhenBeforeDeadline(id)
        onlyWhenPlayerIsInvitee(id)
        onlyWhenValidMove(plaintextMoveInvitee) public payable {

        /**
         * Adjust the balance. The invitee will be able to topup the balance 
         * by providing more value than necessary for the game, in that case 
         * the amount that is left will be added to the balance 
         **/
        balances[msg.sender] = 
            balances[msg.sender].add(msg.value).sub(games[id].amount);
        games[id].plaintextMoveInvitee = plaintextMoveInvitee;
        
        emit GameAccepted(id, games[id].inviter, msg.sender);

    }
    
    /**
     * This method cancels the game. The game can be cancelled by
     * both players, but there are conditions. The invitee will be allowed to 
     * cancel the game unconditionally, because anyway, he/she does not know 
     * the plaintext move of the inviter. The inviter can only cancel the game
     * until the moment that the invitee has accepted the game, so before the 
     * invitee has posted the plaintext move on the blockchain.
     **/
    function cancel(bytes32 id) 
        onlyWhenActive
        onlyWhenNotfinished(id)
        onlyWhenPlayer(id) public {
        
        if (games[id].inviter == msg.sender && 
            games[id].plaintextMoveInvitee != Move.None) {
            revert("Cannot cancel the game, invitee already accepted");
        }
        else {
            games[id].finished = true;
            refund(id);
            freeStorage(id);
            emit GameCancelled(id, msg.sender);
        }

    }

    /**
     * Function that refunds the involved players of a game.
     **/
    function refund(bytes32 id) internal  {

        balances[games[id].inviter] = 
            balances[games[id].inviter].add(games[id].amount);
        if (games[id].plaintextMoveInvitee != Move.None) {
            // The invitee has accepted the game because the move is specified
            balances[games[id].invitee] = 
                balances[games[id].invitee].add(games[id].amount);
        }
        
    }

    /**
     * This method is called by the inviting player in order to reveal the 
     * move in plain text. After, it is possible to continue with the game.
     **/
    function revealMove(Move plaintextMoveInviter, string password, bytes32 id)
        onlyWhenActive 
        onlyWhenNotfinished(id)
        onlyWhenPlayerIsInviter(id)
        onlyWhenValidMove(plaintextMoveInviter) public {
            
        require(games[id].plaintextMoveInvitee != Move.None, 
                "Move cannot be revealed yet, waiting for invitee to accept game");
        require(games[id].inviter == msg.sender, "Invalid game or not a inviter");
        // Check if the inviter speaks the truth
        require(getCommittedMoveHash(msg.sender, plaintextMoveInviter, password) == id,
                "Plaintext move doesn't coincide with committed hashed move");
        /**
         * People are good, don't punish, keep the funds like they are. 
         * The inviter will try again.
         **/                

        /**
         * Regardless of outcome of game or speaking the truth or not, 
         * set the game to finished: After the end of this method, game will be over
         **/
        games[id].finished = true;
        manageGame(id, plaintextMoveInviter);

    }

    /**
     * This function checks the outcome of the game and does the accounting
     **/
    function manageGame(bytes32 id, Move plaintextMoveInviter) internal { 

        uint256 totalMoneyToDivide = games[id].amount.mul(2);
        uint256 amountForContract = totalMoneyToDivide.div(100).mul(profitPercentage);
        profit = profit.add(amountForContract);
        address winner;
        Outcome outcome = determineOutcome(plaintextMoveInviter, games[id].plaintextMoveInvitee);
        uint256 moneyLeftAfterContract = totalMoneyToDivide.sub(amountForContract);
        if (outcome == Outcome.Tie) {
            uint256 splitted = moneyLeftAfterContract.div(2); 
            balances[games[id].inviter] = balances[games[id].inviter].add(splitted);                
            balances[games[id].invitee] = balances[games[id].invitee].add(splitted);                
        }
        else {
            if (outcome == Outcome.InviterWins) {
                balances[games[id].inviter] = 
                    balances[games[id].inviter].add(moneyLeftAfterContract);                
                winner = games[id].inviter;
            }
            else {
                balances[games[id].invitee] = 
                    balances[games[id].invitee].add(moneyLeftAfterContract);
                winner = games[id].invitee;
            }
        }
        
        freeStorage(id);
        emit GameFinished(id, winner);
        
    }

    /**
     * Function that determines the outcome of the game
     **/
    function determineOutcome(Move plaintextMoveInviter, Move plaintextMoveInvitee) 
        onlyWhenValidMove(plaintextMoveInvitee)
        onlyWhenValidMove(plaintextMoveInviter) public pure returns (Outcome) {
            
        return Outcome((3 + uint8(plaintextMoveInviter) - uint8(plaintextMoveInvitee)) % 3);

    }

    /**
     * Fallback function which should be used by a player to topup the balance
     **/
    function() public payable {
        
        require(msg.value > 0, "Value must be greater than 0");
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        emit PlayerToppedUp(msg.value, msg.sender);
        
    }
    
    function changeProfitPercentage(uint8 newProfitPercentage)
        onlyOwner
        onlyWhenInactive public {

        profitPercentage = newProfitPercentage;
        emit ProfitPercentageChanged(newProfitPercentage);
            
    }
        

    /**
     * Function that can be used by players to withdraw their balance
     **/
    function withdraw(uint amount)
        onlyWhenActive public {
        
        require(balances[msg.sender] >= amount, "Balance not available");
        balances[msg.sender] = balances[msg.sender].sub(amount);
        emit FundsWithdrawn(msg.sender);
        msg.sender.transfer(amount);
        
    }

    /** 
     * This function can be called by the owner of the contract in order 
     * to register an address to where the profit of the contract can be 
     * sent.
     **/
    function registerProfitBenificiary(address benificiary) 
        onlyOwner
        onlyWhenInactive public {

        profitBenificiary = benificiary;
        emit ProfitBenificiaryRegistered(benificiary);
        
    }

    /**
     * Function to selfdestruct the contract. The profit will be sent to the 
     * configured profit benificiary.
     **/
    function kill()
        onlyOwner
        onlyWhenInactive public {
        
        selfdestruct(profitBenificiary);
        
    }

    /**
     * Function that can be used by profit benificiary to transfer profit
     * to their account.
     **/
    function transferProfits() 
        onlyWhenProfitBenificiary
        onlyWhenInactive public {
     
        require(profit >= 0, "No profit to be transferred");
        uint256 profitBefore = profit;
        profit = 0;
        emit ProfitTransferred(profitBefore, msg.sender);
        msg.sender.transfer(profitBefore);

    }

    /**
     * This function generates a hash based on the contract address, the 
     * sender, the plaintext move and the password.
     **/
    function getCommittedMoveHash(address sender, Move plaintextMove, string password) 
        public view returns (bytes32) {

        return keccak256(abi.encodePacked(address(this), sender, plaintextMove, password));
        
    }

    /**
     * Clean some storage to claimback gas
     **/
    function freeStorage(bytes32 id) internal {

        // Free storage to give back gas
        games[id].amount = 0;
        games[id].deadline = 0;
        games[id].plaintextMoveInvitee = Move.Rock;

    }
     
}
